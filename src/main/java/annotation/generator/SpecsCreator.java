package annotation.generator;

import static org.apache.commons.lang3.StringUtils.containsIgnoreCase;
import static util.Utils.PACKAGE_NAME;
import static util.Utils.WHITESPACE;
import static util.Utils.getFieldAnnotationValue;
import annotation.Action;
import annotation.AutoGenerated;
import annotation.PageElement;
import com.codeborne.selenide.Condition;
import com.codeborne.selenide.appium.ScreenObject;
import com.squareup.javapoet.AnnotationSpec;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.FieldSpec;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.MethodSpec.Builder;
import com.squareup.javapoet.ParameterSpec;
import com.squareup.javapoet.TypeName;
import com.squareup.javapoet.TypeSpec;
import com.squareup.javapoet.TypeVariableName;
import io.qameta.allure.Step;
import java.time.Duration;
import java.util.List;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.TypeParameterElement;
import javax.lang.model.element.VariableElement;
import javax.lang.model.type.DeclaredType;
import model.Collector;
import model.Element;
import model.Page;
import org.apache.commons.lang3.StringUtils;
import util.Utils;

public class SpecsCreator {

    /*
    Собираем спеку для создания классов в которой хранится вся информация собранная ранее
     */
    public TypeSpec getTypeSpecFromPage(Page page) {
        return TypeSpec.classBuilder(page.getPageName())
            .addModifiers(Modifier.PUBLIC)
            .addFields(generateFieldsSpecByPage(page.getFields()))
            .addMethods(page.getGeneratedMethodSpecs())
            .addAnnotation(AutoGenerated.class)
            .build();
    }

    /*
    Генерирует метод спеку без параметров
    При наличии у аннотации PageElement ненулевого значения timeout
    дополнительно будет сгенерирована строка с ожиданием, указанным в параметре timeout
     */
    public Builder getMethodSpecWithoutParams(ExecutableElement method, VariableElement field, Page page,
        Element element) {
        Builder builder = defaultMethodSpecBuilder(method, field, page, element);
        PageElement pageElement = field.getAnnotation(PageElement.class);
        String actionStatement = String.format("new $T(%s).%s()", field.getSimpleName(), method.getSimpleName());
        return buildStatements(method, field, element, builder, pageElement, actionStatement);
    }

    /*
    Генерирует метод спеку с параметрами
    При наличии у аннотации PageElement ненулевого значения timeout
    дополнительно будет сгенерирована строка с ожиданием, указанным в параметре timeout
     */
    public Builder getMethodSpecWithParams(ExecutableElement method, VariableElement field, Page page,
        Element element) {
        List<ParameterSpec> parameterSpecs = paramSpec(method);
        Builder builder = defaultMethodSpecBuilder(method, field, page, element)
            .addParameters(parameterSpecs);
        PageElement pageElement = field.getAnnotation(PageElement.class);
        String actionStatement = String.format("new $T(%s).%s(" + Utils.formatParamListToString(
            parameterSpecs) + ")", field.getSimpleName(), method.getSimpleName());
        return buildStatements(method, field, element, builder, pageElement, actionStatement);
    }

    private Builder buildStatements(ExecutableElement method, VariableElement field, Element element,
        Builder builder, PageElement pageElement, String actionStatement) {
        if (pageElement != null
            && pageElement.timeout() != 0
            && !containsIgnoreCase(method.getSimpleName().toString(), "wait")) {

            builder.addStatement(
                String.format("new $T(%s).waitElement($T.ofSeconds(%d))", field.getSimpleName(), pageElement.timeout()),
                element.getType(), Duration.class);
            builder.addStatement(actionStatement, element.getType());

        } else {
            builder.addStatement(actionStatement, element.getType());
        }
        return builder.addStatement("return this");
    }

    /*
    Генерирует метод спеку с <TYPE> параметрами
     */
    public Builder getMethodSpecWithTypeParams(ExecutableElement method, VariableElement field, Page page,
        Element element) {
        return getMethodSpecWithParams(method, field, page, element)
            .addTypeVariables(getTypeParamsFromMethod(method.getTypeParameters()));
    }


    private Builder defaultMethodSpecBuilder(ExecutableElement method, VariableElement field, Page page,
        Element element) {
        return MethodSpec.methodBuilder(
                field.getSimpleName().toString() + "_" + method.getSimpleName().toString())
            .addModifiers(Modifier.PUBLIC)
            .addAnnotation(stepAnnotationSpec(method, field, page, element))
            .returns(ClassName.get(PACKAGE_NAME, page.getPageName()));
    }

    private List<TypeVariableName> getTypeParamsFromMethod(List<? extends TypeParameterElement> typeParameterElements) {
        return typeParameterElements.stream()
            .map(TypeVariableName::get)
            .toList();
    }

    /*
    из метода берем все параметры и делаем из них спеки
     */
    private List<ParameterSpec> paramSpec(ExecutableElement method) {
        return method.getParameters().stream()
            .map(ParameterSpec::get)
            .toList();
    }

    /*
    Собираем поля класса с типом SelenideAppiumElement и добавляем к ним все аннотации, которые были на исходных элементах
     */
    private List<FieldSpec> generateFieldsSpecByPage(List<VariableElement> pageFields) {
        return pageFields.stream()
            .map(this::generateFieldSpecFromField)
            .toList();
    }

    /*
    Собираем дефолтную спеку для создания полей
     */
    //todo очень перегружен и плохо читается, надо переделать
    private FieldSpec generateFieldSpecFromField(VariableElement field) {
        FieldSpec.Builder baseBuilder = FieldSpec.builder(TypeName.get(field.asType()),
                field.getSimpleName().toString())
            .addModifiers(Modifier.PRIVATE)
            .addAnnotations(annotationSpecsFromElement(field));

        /*
         Проверка на сопоставление текущего поля с доступными полями из BaseScreen
         при соответствии добавляются аннотации на поле
         Отработает только в том случае, если на поле не было аннотаций и мы не "переопределили" филд
         */
        if (baseBuilder.annotations.isEmpty()) {
            Collector.getInstance().getBaseScreenFields().stream()
                .filter(pageField -> pageField.getSimpleName().equals(field.getSimpleName()))
                .findFirst()
                .ifPresent(pageField -> baseBuilder.addAnnotations(annotationSpecsFromElement(pageField)));
        }
        return baseBuilder.build();
    }

    /*
    Собираем все аннотации с поля в List AnnotationSpec
     */
    private List<AnnotationSpec> annotationSpecsFromElement(javax.lang.model.element.Element element) {
        return element.getAnnotationMirrors()
            .stream()
            .map(AnnotationSpec::get)
            .toList();
    }

    /*
    Собирает Аннотацию @Step
     */
    private AnnotationSpec stepAnnotationSpec(ExecutableElement method, VariableElement field, Page page,
        Element element) {
        return AnnotationSpec.builder(Step.class)
            .addMember("value", "$S", page.getPageName() + WHITESPACE + processStepName(method, field, element))
            .build();
    }

    /*
    Собираем значения из метода, филда, и элемента, чтобы собрать полноценный степ
    пример - Проверяем, что кнопка Удалить не отображается.
    Берется действие из метода, и подставляется в <elementName> значение из поля.
     */
    private String processStepName(ExecutableElement method, VariableElement field, Element element) {
        String typeValue = (((DeclaredType) element.getType()).asElement()).getAnnotation(annotation.Element.class)
            .value();
        String methodValue = method.getAnnotation(Action.class).value();
        String fieldValue = getFieldAnnotationValue(field);
        String stepName = Utils.replaceSubstring(methodValue, "<.*?>", typeValue + WHITESPACE + fieldValue);

        /*
        Дополнительные ифы, чтобы проставить правильно склонения
         */
        if (stepName.contains("Нажимаем на кнопка")) {
            stepName = stepName.replace("Нажимаем на кнопка", "Нажимаем на кнопку");
        }

        if (stepName.contains("Нажимаем на картинка")) {
            stepName = stepName.replace("Нажимаем на картинка", "Нажимаем на картинку");
        }
        return stepName;
    }

    /*
    Генерирует методы для инициализации скринов сгенерированных ранее
     */
    public MethodSpec generateScreenMethods(javax.lang.model.element.Element element) {
        return MethodSpec.methodBuilder(StringUtils.uncapitalize(element.getSimpleName().toString()))
            .addModifiers(Modifier.PUBLIC)
            .returns(ClassName.get(PACKAGE_NAME, element.getSimpleName().toString()))
            .addStatement("return $T.screen(" + element.getSimpleName().toString() + ".class)", ScreenObject.class)
            .build();
    }

    /*
    Генерирует вложенные методы для внутренних инициализаций пейджей
     */
    public MethodSpec generateInnerScreenMethods(ExecutableElement element) {
        /*
        test.page.LoginScreen -> LoginScreen
         */
        String className = ((DeclaredType) element.getReturnType())
            .asElement().getSimpleName().toString();

        return MethodSpec.methodBuilder(element.getSimpleName().toString())
            .addModifiers(Modifier.PUBLIC)
            .returns(ClassName.get(PACKAGE_NAME, className))
            .addStatement("return $T.screen(" + className + ".class)", ScreenObject.class)
            .build();
    }

    /*
    Генерирует методы для возможности вернуть поле класса
     */
    public MethodSpec generateGetMethods(VariableElement element) {
        return MethodSpec.methodBuilder(element.getSimpleName().toString() + "_get")
            .addModifiers(Modifier.PUBLIC)
            .returns(TypeName.get(element.asType()))
            .addStatement("return this." + element.getSimpleName().toString())
            .build();
    }

    /*
    Генерирует методы isPresent для каждого поля
     */
    public MethodSpec generateIsPresentMethods(VariableElement element) {
        return MethodSpec.methodBuilder(element.getSimpleName().toString() + "_isPresent")
            .addModifiers(Modifier.PUBLIC)
            .returns(boolean.class)
            .addStatement("return this." + element.getSimpleName().toString() + ".is($T.visible)", Condition.class)
            .build();
    }

    /*
    Генерирует методы isPresent с duration для каждого поля
    */
    public MethodSpec generateIsPresentMethodsWithDuration(VariableElement element) {
        return MethodSpec.methodBuilder(element.getSimpleName().toString() + "_isPresent")
            .addParameter(Duration.class, "duration")
            .addModifiers(Modifier.PUBLIC)
            .returns(boolean.class)
            .addStatement("return this." + element.getSimpleName().toString() + ".is($T.visible, duration)",
                Condition.class)
            .build();
    }
}
