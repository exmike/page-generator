package annotation.generator;

import static org.apache.commons.lang3.StringUtils.containsIgnoreCase;
import static util.Utils.PACKAGE_NAME;
import static util.Utils.checkCorrectMethods;
import static util.Utils.isNotAnnotated;
import static util.Utils.validate;
import annotation.AutoGenerated;
import annotation.BaseElement;
import annotation.BasePageObject;
import annotation.PageElement;
import annotation.PageObject;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.TypeSpec;
import java.util.ArrayList;
import java.util.List;
import javax.annotation.processing.ProcessingEnvironment;
import javax.annotation.processing.RoundEnvironment;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.TypeElement;
import javax.lang.model.element.VariableElement;
import javax.lang.model.util.ElementFilter;
import lombok.RequiredArgsConstructor;
import lombok.SneakyThrows;
import model.Collector;
import model.Element;
import model.Page;
import org.apache.commons.lang3.StringUtils;
import util.Logger;
import util.Utils;

@RequiredArgsConstructor
public class PageGenerator {

    private final Logger log;
    private final RoundEnvironment roundEnv;
    private final SpecsCreator specsCreator;
    private final ProcessingEnvironment processingEnvironment;
    private final Collector collector = Collector.getInstance();

    /**
     * Метод, который собирает все элементы проаннотированные Element и к каждому Element добавляет все
     * методы из BaseElement
     */
    //todo очень перегружен и плохо читается, надо переделать
    public PageGenerator collectElements() {
        validateBaseElement();
        List<Element> elements = new ArrayList<>();
        List<ExecutableElement> baseMethods = getBaseMethods();

        roundEnv.getElementsAnnotatedWith(annotation.Element.class)
            .forEach(element -> {
                if (element.getAnnotation(annotation.Element.class).value().isEmpty()) {
                    throw new RuntimeException(
                        String.format("Значение в аннотации Element %s не должно быть пустым",
                            element.getSimpleName()));
                }
                List<ExecutableElement> publicElementMethods = new ArrayList<>(getPublicMethods(element));
                /*
                Проверка, что у бейз элемента есть суперкласс, который не Object
                для таких не будут генерироваться методы из BaseElement
                 */
                if (!((TypeElement) element).getSuperclass().toString().equals(Object.class.getName())) {
                    publicElementMethods.addAll(baseMethods);
                }
                checkCorrectMethods(publicElementMethods);
                elements.add(
                    new Element(element.asType(), new ArrayList<>(publicElementMethods)));
            });
        validate(elements, annotation.Element.class);
        this.collector.setElement(elements);
        return this;
    }

    /*
    Получение всех методов из класса аннотированного BaseElement
     */
    private List<ExecutableElement> getBaseMethods() {
        return getPublicMethods(roundEnv.getElementsAnnotatedWith(BaseElement.class)
            .stream().toList().get(0));
    }

    /*
    К каждой page генерируется пачка методов на основе доступных Element'ов
     */
    public PageGenerator generateMethodsToPage() {
        this.collector.getPages().forEach(page -> {
            /*
            Генерация вложенных инициализаций пейджей
            фильтруем по методам, которые содержат в названии widget
             */
            page.getMethods().stream()
                .filter(method -> StringUtils.containsIgnoreCase(method.toString(), "widget"))
                .forEach(method -> page.addSpec(specsCreator.generateInnerScreenMethods(method)));

            /*
            Генерация методов на основе доступных полей
             */
            page.getFields().forEach(field ->
            {
                // Генерация методов на основе доступных полей
                generateMethodSpecToPage(field, page);

                //Генерация методов, которые будут возвращать поля класса(геттеры полей)
                page.addSpec(specsCreator.generateGetMethods(field));

                //Генерирует методы isPresent для каждого поля
                if ((!containsIgnoreCase(field.getSimpleName().toString(), "elementsList"))) {
                    page.addSpec(specsCreator.generateIsPresentMethods(field));
                    page.addSpec(specsCreator.generateIsPresentMethodsWithDuration(field));
                }
            });

        });
        return this;
    }

    /**
     * Метод собирает все пейджы, которые проаннотированны PageObject'ом, собирая public поля находящиеся в них
     */
    //todo очень перегружен и плохо читается, надо переделать
    public PageGenerator collectPages() {
        List<Page> pages = this.roundEnv.getElementsAnnotatedWith(PageObject.class)
            .stream()
            .map(page -> {
                List<VariableElement> fields = ElementFilter.fieldsIn(page.getEnclosedElements());
                List<ExecutableElement> methods = ElementFilter.methodsIn(page.getEnclosedElements());
                checkCorrectFields(fields, page);
                return new Page(page.getSimpleName().toString(), fields, methods);
            }).toList();
        validate(pages, PageObject.class);
        this.collector.setPages(pages);
        return this;
    }

    //todo очень перегружен и плохо читается, надо переделать, описание
    private void checkCorrectFields(List<? extends javax.lang.model.element.Element> elements, javax.lang.model.element.Element page) {
        List<String> basePageElementFields = collector.getBaseScreenFields().stream()
            .map(field -> field.getSimpleName().toString())
            .toList();

        elements.forEach(field -> {
            boolean isNotBasePageField = !basePageElementFields.contains(field.getSimpleName().toString());

            if (isNotBasePageField && isNotAnnotated(field, PageElement.class)) {
                throw new RuntimeException(String.format("Поле %s в классе %s должно быть c аннотацией PageElement",
                    field, page.getSimpleName()));
            }
            if (isNotBasePageField && field.getAnnotation(PageElement.class).value().isEmpty()) {
                throw new RuntimeException(
                    String.format("Поле %s в классе %s в аннотации PageElement должно иметь не пустое значение",
                        field, page.getSimpleName()));
            }
        });
    }

    /*
    Собираем поля из BaseScreen
     */
    private PageGenerator collectBaseScreenFields() {
        collector.setBaseScreenFields(
            roundEnv.getElementsAnnotatedWith(BasePageObject.class)
                .stream()
                .flatMap(baseScreenFields -> ElementFilter.fieldsIn(baseScreenFields.getEnclosedElements()).stream())
                .toList());
        return this;
    }

    /*
    Метод для сохранения сгенерированных MethodSpec в каждый из объектов Page
     */
    //todo очень перегружен и плохо читается, надо переделать
    private void generateMethodSpecToPage(VariableElement field, Page page) {
        Element element = this.collector.getElement().stream()
            .filter(el -> Utils.isFieldTypeCorrect(el, field))
            .findFirst()
            .orElseThrow(() -> new RuntimeException(
                String.format("У поля %s в классе %s не смогли определить тип, доступные типы: %s",
                    field.getSimpleName().toString(), page.getPageName(), collector.getStringElements())));

        //todo rework
        element.getMethods().forEach(method -> {
            if (method.getParameters().isEmpty() && method.getTypeParameters().isEmpty()) {
                page.addSpec(specsCreator.getMethodSpecWithoutParams(method, field, page, element).build());
            } else if (!method.getTypeParameters().isEmpty()) {
                page.addSpec(specsCreator.getMethodSpecWithTypeParams(method, field, page, element).build());
            } else if (!method.getParameters().isEmpty()) {
                page.addSpec(specsCreator.getMethodSpecWithParams(method, field, page, element).build());
            }
        });
    }

    /*
    Метод для генерации всех классов на основе собранных объектов Page
     */
    public List<TypeSpec> generateClasses() {
        return this.collector.getPages().stream()
            .map(specsCreator::getTypeSpecFromPage)
            .toList();
    }

    /*
    Получение всех публичных методов из виджета
     */
    private List<ExecutableElement> getPublicMethods(javax.lang.model.element.Element element) {
        return ElementFilter.methodsIn(element.getEnclosedElements())
            .stream()
            .filter(method -> method.getModifiers().contains(Modifier.PUBLIC))
            .toList();
    }

    public void generateScreenManager() {
        List<MethodSpec> methodSpecs = this.roundEnv.getElementsAnnotatedWith(AutoGenerated.class).stream()
            .filter(method -> !StringUtils.containsIgnoreCase(method.toString(), "widget"))
            .map(specsCreator::generateScreenMethods)
            .toList();

        TypeSpec screenManagerSpec = TypeSpec.classBuilder("ScreenManager")
            .addModifiers(Modifier.PUBLIC)
            .addMethods(methodSpecs)
            .build();
        this.writeClass(screenManagerSpec);
    }

    /*
    Основной метод для поэтапной генерации классов
     */
    public void generatePages() {
        //собрали доступные Element'ы
        this.collectElements()
            //собрали доступные поля в BasePage
            .collectBaseScreenFields()
            //собрали доступные PageObject'ы
            .collectPages()
            //сгенерировали для каждой Page методы
            .generateMethodsToPage()
            //сгенерировали классы на основе ранее сгенерированных pages и записал их в Filer
            .generateClasses()
            .forEach(this::writeClass);
    }

    @SneakyThrows
    private void writeClass(TypeSpec typeSpec) {
        JavaFile.builder(PACKAGE_NAME, typeSpec).build().writeTo(this.processingEnvironment.getFiler());
    }

    /*
    Проверка наличия BaseElement в единственном экземпляре
     */
    private void validateBaseElement() {
        long baseElementCount = roundEnv.getElementsAnnotatedWith(BaseElement.class).size();
        if (baseElementCount != 1) {
            throw new RuntimeException(
                "Ожидается, что будет одна аннотация BaseElement но их: " + baseElementCount);
        }
    }
}
