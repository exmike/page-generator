package annotation.generator;

import static util.Utils.PACKAGE_NAME;
import static util.Utils.checkCorrectMethods;
import static util.Utils.getMobileElementNameFromField;
import static util.Utils.getMobileElementTypeName;
import static util.Utils.isNotAnnotated;
import static util.Utils.validate;
import annotation.AutoGenerated;
import annotation.BaseMobileElement;
import annotation.BasePageObject;
import annotation.MobileElement;
import annotation.PageElementGen;
import annotation.PageObject;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.TypeSpec;
import java.util.ArrayList;
import java.util.List;
import javax.annotation.processing.ProcessingEnvironment;
import javax.annotation.processing.RoundEnvironment;
import javax.lang.model.element.Element;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.VariableElement;
import javax.lang.model.util.ElementFilter;
import lombok.RequiredArgsConstructor;
import lombok.SneakyThrows;
import model.Collector;
import model.MobileElementModel;
import model.Page;
import org.apache.commons.lang3.StringUtils;
import util.Logger;

@RequiredArgsConstructor
public class PageGenerator {

    private final Logger log;
    private final RoundEnvironment roundEnv;
    private final SpecsCreator specsCreator;
    private final ProcessingEnvironment processingEnvironment;
    private final Collector collector = Collector.getInstance();

    /**
     * Метод, который собирает все элементы проаннотированные MobileElement и к каждому MobileElement добавляет все
     * методы из BaseMobileElement
     */
    public PageGenerator collectMobileElements() {
        validateBaseMobileElement();
        List<MobileElementModel> mobileElements = new ArrayList<>();
        List<ExecutableElement> baseMobileMethods = getBaseMobileMethods();

        roundEnv.getElementsAnnotatedWith(MobileElement.class)
            .forEach(element -> {
                if (element.getAnnotation(MobileElement.class).value().isEmpty()) {
                    throw new RuntimeException(
                        String.format("Значение в аннотации MobileElement %s не должно быть пустым",
                            element.getSimpleName()));
                }
                List<ExecutableElement> publicMobileElementMethods = new ArrayList<>(getPublicMethods(element));
                publicMobileElementMethods.addAll(baseMobileMethods);
                checkCorrectMethods(publicMobileElementMethods);
                mobileElements.add(
                    new MobileElementModel(element.asType(), new ArrayList<>(publicMobileElementMethods)));
            });
        validate(mobileElements, MobileElement.class);
        this.collector.setMobileElements(mobileElements);
        return this;
    }

    /*
    Получение всех методов из класса аннотированного BaseMobileElement
     */
    private List<ExecutableElement> getBaseMobileMethods() {
        return getPublicMethods(roundEnv.getElementsAnnotatedWith(BaseMobileElement.class)
            .stream().toList().get(0));
    }

    /*
    К каждой page генерируется пачка методов на основе доступных MobileElement'ов
     */
    public PageGenerator generateMethodsToPage() {
        this.collector.getPages().forEach(page -> {
            /*
            Генерация вложенных инициализаций пейджей
             */
            page.getMethods().forEach(method -> page.addSpec(specsCreator.generateInnerScreenMethods(method)));

            /*
            Генерация методов на основе доступных полей
             */
            page.getFields().forEach(field -> generateMethodSpecToPage(field, page));
        });
        return this;
    }

    /**
     * Метод собирает все пейджы, которые проаннотированны PageObject'ом, собирая public поля находящиеся в них
     */
    public PageGenerator collectPages() {
        List<Page> pages = this.roundEnv.getElementsAnnotatedWith(PageObject.class)
            .stream()
            .map(page -> {
                List<VariableElement> fields = ElementFilter.fieldsIn(page.getEnclosedElements());
                //todo проверки на методы тоже обязательно отсеивать ненужные
                List<ExecutableElement> methods = ElementFilter.methodsIn(page.getEnclosedElements());
                checkCorrectFields(fields, page);
                return new Page(page.getSimpleName().toString() + "Gen",
                    fields, methods);
            }).toList();
        validate(pages, PageObject.class);
        this.collector.setPages(pages);
        return this;
    }

    private void checkCorrectFields(List<? extends Element> elements, Element page) {
        List<String> basePageElementFields = collector.getBaseScreenFields().stream()
            .map(field -> field.getSimpleName().toString())
            .toList();

        elements.forEach(field -> {
            boolean isNotBasePageField = !basePageElementFields.contains(field.getSimpleName().toString());

            if (isNotBasePageField && isNotAnnotated(field, PageElementGen.class)) {
                throw new RuntimeException(String.format("Поле %s в классе %s должно быть c аннотацией PageElementGen",
                    field, page.getSimpleName()));
            }
            if (isNotBasePageField && field.getAnnotation(PageElementGen.class).value().isEmpty()) {
                throw new RuntimeException(
                    String.format("Поле %s в классе %s в аннотации PageElement должно иметь не пустое значение",
                        field, page.getSimpleName()));
            }
        });
    }

    private PageGenerator collectBaseScreenFields() {
        collector.setBaseScreenFields(
            roundEnv.getElementsAnnotatedWith(BasePageObject.class)
                .stream()
                .flatMap(baseScreenFields -> ElementFilter.fieldsIn(baseScreenFields.getEnclosedElements()).stream())
                .toList());
        return this;
    }

    /*
    Метод для сохранения сгенерированных MethodSpec в каждый из объектов Page
     */
    private void generateMethodSpecToPage(VariableElement field, Page page) {
        String elementTypeNameFromField = getMobileElementNameFromField(field);

        MobileElementModel element = this.collector.getMobileElements().stream()
            .filter(currentElement -> StringUtils.containsIgnoreCase(elementTypeNameFromField,
                getMobileElementTypeName(currentElement)))
            .findFirst()
            .orElseThrow(() -> new RuntimeException(
                String.format("У поля %s в классе %s не смогли определить тип, доступные типы: %s",
                    field.getSimpleName().toString(), page.getPageName(), collector.getStringMobileElements())));

        //todo rework
        element.getMethods().forEach(method -> {
            if (method.getParameters().isEmpty() && method.getTypeParameters().isEmpty()) {
                page.addSpec(specsCreator.getMethodSpecWithoutParams(method, field, page, element).build());
            } else if (!method.getTypeParameters().isEmpty()) {
                page.addSpec(specsCreator.getMethodSpecWithTypeParams(method, field, page, element).build());
            } else if (!method.getParameters().isEmpty()) {
                page.addSpec(specsCreator.getMethodSpecWithParams(method, field, page, element).build());
            }
        });
    }

    /*
    Метод для генерации всех классов на основе собранных объектов Page
     */
    public List<TypeSpec> generateClasses() {
        return this.collector.getPages().stream()
            .map(specsCreator::getTypeSpecFromPage)
            .toList();
    }

    /*
    Получение всех публичных методов из виджета
     */
    private List<ExecutableElement> getPublicMethods(Element mobileElement) {
        return ElementFilter.methodsIn(mobileElement.getEnclosedElements())
            .stream()
            .filter(method -> method.getModifiers().contains(Modifier.PUBLIC))
            .toList();
    }

    @SneakyThrows
    public void generateScreenManager() {
        this.collector.setGeneratedPages(this.roundEnv.getElementsAnnotatedWith(AutoGenerated.class).stream().toList());

        List<MethodSpec> methodSpecs = this.collector.getGeneratedPages().stream()
            .map(specsCreator::generateScreenMethods)
            .toList();

        TypeSpec screenManagerSpec = TypeSpec.classBuilder("ScreenManagerGen")
            .addModifiers(Modifier.PUBLIC)
            .addMethods(methodSpecs)
            .build();
        this.writeClass(screenManagerSpec);
    }

    /*
    Основной метод для поэтапной генерации классов
     */
    public void generatePages() {
        //собрали доступные MobileElement'ы
        this.collectMobileElements()
            //собрали доступные поля в BasePage
            .collectBaseScreenFields()
            //собрали доступные PageObject'ы
            .collectPages()
            //сгенерировали для каждой Page методы
            .generateMethodsToPage()
            //сгенерировали классы на основе ранее сгенерированных pages и записал их в Filer
            .generateClasses()
            .forEach(this::writeClass);
    }

    @SneakyThrows
    private void writeClass(TypeSpec typeSpec) {
        JavaFile.builder(PACKAGE_NAME, typeSpec).build().writeTo(this.processingEnvironment.getFiler());
    }

    /*
    Проверка наличия BaseMobileElement в единственном экземпляре
     */
    private void validateBaseMobileElement() {
        long baseMobileElementCount = roundEnv.getElementsAnnotatedWith(BaseMobileElement.class).size();
        if (baseMobileElementCount != 1) {
            throw new RuntimeException(
                "Ожидается, что будет одна аннотация BaseMobileElement но их: " + baseMobileElementCount);
        }
    }
}
